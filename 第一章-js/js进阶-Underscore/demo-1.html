<html>

<head>
    <meta name="renderer" content="webkit">
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <title>js另外一种库underscore</title>
    <meta name="author" content="zhaomi">
    <meta name="viewport"
        content="width=device-width,initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="format-detection" content="telephone=no">
</head>

<body>
    <div id="div"></div>
    <script>
        // var _ = {
        //     owner: 'max'
        // };
    </script>
    <script src="underscore-v1.2.js"></script>
    <script>

        // 设计模式 --》代理模式
        // 设计原则--》单一职责原则
        // 记忆--》缓存

        // function add3(a,b){
        //     return (a+b)*3
        // }

        // let memorizeadd = memorize(add3,function(){
        //     let arg = JSON.stringify(Array.prototype.slice.call(arguments))
        //     return arg
        // })

        // console.log(memorizeadd(2,5,9));
        // console.log(memorizeadd(2,5,9));
        // console.log(memorizeadd(2,5,4));


        // function  memorize(fn,callback){
        //     var cache = {}
        //     return function(){
        //         // 获取一个数组
        //         // console.log(cache);
        //         let key = callback ? callback.apply(this,arguments) : ''
        //         if(key in cache){
        //             // console.log("使用缓存");
        //             return cache[key]
        //         }else{
        //             // console.log("jdjddjddjbu不使用缓存");
        //             return cache[key]=fn.apply(this,arguments)
        //         }
        //     }
        // }
        // // 时间换空间：通过缓存解决了内存占用的
        // console.time('no use cache:');
        // for(let i=0;i<1000;i++){
        //     add3(7484848,988449);
        // }
        // console.timeEnd('no use cache:');

        // console.time('use cache:');
        // for(let i=0;i<1000;i++){
        //     memorizeadd(7484848,988449);
        // }
        // console.timeEnd('use cache:');

        // let propValue = function(obj){
        //     return obj.value
        // }
        // let memorizeValue = memorize(propValue,
        // function(){
        //     let args = JSON.stringify(Array.prototype.slice.call(arguments))
        //     return args
        // });
        // console.log(memorizeValue({value:1}));
        // console.log(memorizeValue({value:1}));
        // console.log(memorizeValue({value:2}));

        //---------------------
        // 纯函数
        // console.log(_.unique([1, 2, 3, 4, 5, 4, 5]));
        // console.log(_.unique([1, 2, 3, 4, 5, 4, 5, 6, "a", "1", "A"], function (value) {
        //     return typeof value === "string" ? value.toLowerCase() : value;
        // }));
        // _([1, 2, 3, 4, 5, 4, 5]); //调用underscore,携带数据,创建实例对象
        // 链式调用
        // console.log(_([1, 2, 3, 4, 5, 4, 5]).chain().unique().map().value());
        // underscore对undefined的处理
        // js里 undefined易被篡改
        // void(0);
        // 迭代器 iteratee
        // cb 优化迭代器
        // optimizeCb 最终生成
        // ===========map===========
        // 专门为对象服务的map方法
        // 迭代函数改变对象的values值
        // 返回对象副本
        // var obj = {
        //     name: "zm"
        // };
        // console.log(_.map([4, 5, 6, 7], function (value, index, object) {
        //     return value * 3
        // }, obj));
        // console.log(_.map({
        //     age1: 1,
        //     age2: 12,
        //     age3: 15
        // }, function (value, index, object) {
        //     return value * 3
        // }, obj));
        // console.log(_.map({
        //     age1: 1,
        //     age2: 12,
        //     age3: 15
        // }, obj));

        // 3.1.4 rest
        // 	//ES6 引入 rest 参数(形式为...变量名)用于获取函数的多余参数
        // 	function test(count, rest){
        // 		console.log(rest)
        // 	}
        // 	test(1,2,3,4);
        //[1,[2,3,4]]
        // function test(count, set, rest) {
        //     console.log(count);
        //     console.log(set);
        //     console.log(rest); //[2,3,4]
        // }
        // //包装器
        // var restTest = _.restArguments(test);
        // restTest(1, 2, 3, 4, 5);
        // 真值检测
        // console.log(_.reduce([5, 6, 7], function (memo, value, index, obj) {
        //     // console.log(memo); 5;11
        //     // console.log(value);6;7

        //     return memo + value; //1+2
        // }, 3));
        // 3 + 5； + 6； + 7


        // console.log(_.filter([12, 50, 2, 4, 6, 13, 12], function (elem) {
        //     return elem < 10;
        // }));

        // 3.2.3 indexOf() 和lastindexOf
        // 排序后的数组通过二分查找法查找数组中目标值 5 的下标值
        let arr02 = []
        for(let i=0;i<12345;i++){
            let random = Math.floor(10+i)
            arr02.push(random)
        }
        // console.log(arr02)
        // console.log(_.indexOf(arr02, 12323, true));


        


        // console.log(_.indexOf([1, 2, 3, 4, 5, NaN, 7], NaN, true));
        // console.log(_.lastIndexOf([5, 8, 2, 3, 1, 10], 5));

        // 数组洗牌算法
        // console.log(_.random(10, 15));
        // console.log(_.sample([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5));
        // // console.log(_.sample({
        //     age1: 1,
        //     age2: 12,
        //     age3: 15
        // }, 5));
        // var shuffleArray = _.shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        // console.log(shuffleArray);
        // //    深度摊平
        // console.log(_.flatten([1, [2, 3, 4, 5],
        //     [6, 7, 8, 9], 10
        // ]));
        // //    浅摊平
        // console.log(_.flatten([1, [2, 3, [4, 5]],
        //     [6, [7, 8, ], 9], 10
        // ], true));
        // console.log(_.initial([5, 8, 2, 3, 1, 10], 3));
        // console.log(_.rest([5, 8, 2, 3, 1, 10], 3));
        // // 数组去重
        // console.log("数组去重+1 : " + _.unique([5, 5, 2, 3, 2, 10], function (value, index, obj) {
        //     return value + 1;
        // }));
        // 去除假值
        // var arr = [NaN, 1, 21, 32, NaN, 41, 5];
        // console.log(_.compact(arr));
        // console.log("compact 去除假值 : " + _.compact([5, 5, "", 3, NaN, 10, undefined]));
        // // 返回某一个范围内的数值组成的数组
        // console.log(_.range(5));
        // console.log(_.range(15, 11));
        // console.log(_.range(1, 11, 2));

        // 思路一：通过快速排序
        let arr03=[49,38,65,101,76,13,27,49,55,1]
        arr02 = _.shuffle(arr02)
        console.log(arr02);
        // 去重、去假值
        arr03 = _.compact(_.unique(arr03))
        arr02 = _.compact(_.unique(arr02))
        console.time('test');
        console.log(sort(arr02))
        // 效率最低的
        function sort(arr){ 
            for(var i=0;i<arr.length-1;i++){ 
                for(var j=i+1;j<arr.length;j++){ 
                    if(arr[i]>arr[j]){/*如果前面的数据比后面的大就交换位置*/
                        var list=arr[i]; 
                        arr[i]=arr[j]; 
                        arr[j]=list; 
                    }  
                } 
            }  
            return arr; 
        } 
        console.timeEnd('test');

        console.time('test2');
        
        // 阮一峰老师优化版快速查找
        var quickSort = function(arr) {
        　　if (arr.length <= 1) {//如果数组长度小于等于1无需判断直接返回即可 
                return arr;
            }
        　　var pivotIndex = Math.floor(arr.length / 2);//取基准点 
        　　var pivot = arr.splice(pivotIndex, 1)[0];//取基准点的值,splice(index,1)函数可以返回数组中被删除的那个数
        　　var left = [];//存放比基准点小的数组
        　　var right = [];//存放比基准点大的数组 
        　　for (var i = 0; i < arr.length; i++){ //遍历数组，进行判断分配 
        　　　　if (arr[i] < pivot) {
        　　　　　　left.push(arr[i]);//比基准点小的放在左边数组 
        　　　　} else {
        　　　　　　right.push(arr[i]);//比基准点大的放在右边数组 
        　　　　}
        　　}
                //递归执行以上操作,对左右两个数组进行操作，直到数组长度为<=1； 
        　　return quickSort(left).concat([pivot], quickSort(right));
        };
        console.log(quickSort(arr03))
        console.timeEnd('test2');

        console.time('test3');

        console.log(quickSort2(arr03))
        // 快速查找原始写法  用时最短，效率最高
        function quickSort2(arr, left, right) {
            var len = arr.length,
                partitionIndex,
                left = typeof left != 'number' ? 0 : left,
                right = typeof right != 'number' ? len - 1 : right;

            if (left < right) {
                partitionIndex = partition(arr, left, right);
                quickSort(arr, left, partitionIndex-1);
                quickSort(arr, partitionIndex+1, right);
            }
            
            return arr;
        }
        function partition(arr, left ,right) {     //分区操作
            var pivot = left,                      //设定基准值（pivot）
                index = pivot + 1;
            for (var i = index; i <= right; i++) {
                if (arr[i] < arr[pivot]) {
                    swap(arr, i, index);
                    index++;
                }        
            }
            swap(arr, pivot, index - 1);
            
            
            return index-1;
        }
        function swap(arr, i, j) {
            var temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
       console.timeEnd('test3');

        


        //局部应用一个函数填充在任意个数的参数,不改变其动态this值。
        // var add = function (a, b, c) {
        //     return a + b + c;
        // };
        // var partialAdd = _.partial(add, 5, 1); //提取出来
        // console.log(partialAdd(2)); //    提出来    => 15


        // function add(a, b) {
        //     return a + b;
        // }
        // jquery里的做法
        // var BindAdd = add.bind(this, 5);
        // console.log(BindAdd(5)); //10

        // var hasher = function () {
        //     var n = arguments[0];
        //     return n + "zm";
        // }

        //这个数列从第3项开始,每一项都等于前两项之和.
        //1 1  2  3 5 8 13 21 34 .....
        // var fibonacci = _.memoize(function (n) {
        //     return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
        // }, hasher);

        // fibonacci(3);

        // console.log(fibonacci.cache);
        // // 延迟函数
        // _.delay(function (name) {
        //     console.log("--settimeout--" + name);
        // }, 1500, "zm");

        // // 组合函数
        // function A(data) {
        //     return 2 * data;
        // }

        // function B(data) {
        //     return 2 + data;
        // }

        // function C(data) {
        //     return 2 - data;
        // }
        // 从左到右
        // function compose() {
        //     var lenght = arguments.length;
        //     var funcs = [].slice.call(arguments, 0, lenght - 1);
        //     var data = [].slice.call(arguments, lenght - 1);
        //     // console.log(funcs);
        //     return funcs.reduce(function (memo, func) {
        //         // console.log(memo);
        //         return func(memo);
        //     }, data);
        // }
        // var result = compose(C, B, A, 3);
        // console.log(result);
        // 函数式编程也是函数柯里化的一种形式
        // var welcome = _.compose(A, B, C);
        // console.log(welcome(1));
        // // Xss攻击，在源码里植入脚本代码
        // var xssvalue = _.escape("<div><a href='www.baidu.com'>Xss攻击</a></div>");
        // console.log(xssvalue);

        // var root = typeof self == 'object' && self.self === self && self ||
        //      typeof global == 'object' && global.global === global && global ||
        //      this;
        // root._ = _;
        //  _ 将会依托于当前的所处环境，挂载到不同的全局空间当中。 以上代码中，我们没有看到 window 对象的引用，而选择使用了self ，self 保存当前 window 对象的引用。相比window，self 还能用于一些不具有窗口的上下文环境中，比如 Web Workers。

        // 所以，为了服务于更多场景，推荐使用更加通用的 self 对象。
        // 看不懂的一道题
        // var length = 10;

        // function fn() {
        //     console.log(this.length);
        // }
        // var obj = {
        //     length: 5,
        //     method: function (fn1) {
        //         arguments[0]();
        //     }
        // };
        // obj.method(fn, 123);
        // 思考题






        var obj = {
            data: {
                name: "zm"
            }
        };
        // 引入underscore后
        // var _underscore = _.noConflict();
        // console.log(_underscore.clone(obj)); //{name: "zm"}
        // console.log(_.owner); // => max

        var clone01 = _.clone(obj);

        console.log("clone:", clone01.data === obj.data);
        clone01.age = '20';
        var clone02 = _.deepclone(obj);
        console.log("clonedeep:", clone02.data === obj.data);
        clone02.sex = '男';
        // console.log(obj);
        // console.log(clone01);
        // console.log(clone02);
        var arr = [1, 3, 5, 6, 8];
        var arrclone = _.deepclone(arr);
        // console.log(arr === arrclone);

        // ============with导致内存泄漏========================
        // var count = 0;
        // function foo() {
        //     var obj = {
        //         count: 1
        //     }
        //     with(obj) {
        //         var count = 2
        //     }
        //     console.log(obj.count); //2
        //     console.log(count) //undifend
        // }
        // foo();

        // function foo(obj) {
        //     with(obj) {
        //         a = 2;
        //     }
        // }

        // var o1 = {
        //     a: 3
        // };

        // var o2 = {
        //     b: 3
        // }

        // foo(o1);
        // console.log(o1.a); //2

        // foo(o2);
        // console.log(o2.a); //underfined
        // console.log(a);

        // 1 .toString() 就是装箱转化 隐式转换
        // [] + []  "" 
        // [] + {} "[object Object]"
        // {} + {}   "[object Object][object Object]"
        // {}+[] 0     //{} 代码块 +[] =0

        // 内部底层是拆箱转化
        // 先看[].valueOf() 是否有值， 如果结果是[],则接着查看[].toString()里是否有值

        // ====================================
    </script>
</body>

</html>